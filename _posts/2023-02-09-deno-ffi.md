---
title: deno에서 rust 코드를 실행해보자 (deno ffi)
tags: [ deno, rust, ffi ]
category: programming
date: 2023-02-09 23:01:12 +0900
lng_pair: id_deno_ffi
---

# Deno에서 rust 코드를 사용할 수는 없을까?

가능합니다! Deno에서는 이를 위해 FFI (Foreign Function Interface) API를 제공하고
있습니다. 간단하게 FFI API를 사용하는 프로젝트를 한번 만들어 보면서 어떤
느낌인지 훑어봅시다.

# Deno FFI

Deno FFI는 C/C++/Rust 등의 언어로 작성된 공유라이브러리(shared library)를
직접적으로 사용할 수 있게 해주는 기능입니다.

사실 그래서 굳이 rust일 필요는 없고 C++로 작성해도 됩니다. 핵심은 언어가 아니라
shared library 이니까요.

자세한 내용은 공식문서(https://deno.land/manual@v1.30.0/runtime/ffi_api)를
참조합시다.

# 프로젝트 init

rust 프로젝트를 기반으로 시작해봅시다.

```
cargo new hello-ffi --lib
```

`Cargo.toml`에 추가해줍니다.

```
[lib]
crate-type = ["cdylib"]
```

"cdylib"은 rust 코드를 C와 호환되는 스타일의 공유 라이브러리로 빌드해야함을
알려줍니다.

deno도 세팅해줍니다.

```
deno init
```

```
├── Cargo.toml
├── deno.jsonc
├── main.ts
└── src
    └── lib.rs
```

이런 구조가 되면 성공입니다. deno 코드는 루트 디렉토리에 있고, rust는 src에 있고
혼란스럽습니다만 저희의 목표는 간단하게 ffi를 테스트 해보는 거니 무시하구
진행해봅시다.

# 함수 작성

```rust
// src/lib.rs
#[no_mangle]
pub extern "C" fn add(left: usize, right: usize) -> usize {
    left + right
}
```

"no_mangle"은 컴파일 시 이 함수를 mangling 하지말라고 알려줍니다. 맹글링은
컴파일러가 좀 더 자신의 입맛에 맞게 (사람이 읽기는 힘든) 함수 등의 이름을 바꾸는
것을 말하는데, 맹글링 규칙을 모르는 외부에 함수를 노출해야하는 상황이므로 이
기능을 잠시 꺼야합니다. 만약 `#[no_mangle]`을 붙이지 않는다면, 외부에서는
"add"라는 함수를 찾을 수 없게 됩니다.

함수의 리턴 타입과 파라미터 타입은
https://deno.land/manual@v1.30.0/runtime/ffi_api#supported-types 을 따라야
합니다. Deno 내부 FFI 구현을 보면 간단한 struct 타입도 지원하고 있긴 하지만
아직까지는 docs에 공개된 타입만을 사용하는게 안전해보입니다.

# 빌드!

```
cargo build
```

`target/debug`에 공유 라이브러리 파일이 생성 된걸 확인하셨다면 성공입니다!

# Deno에서 사용하기

```ts
// main.ts

const dylib = Deno.dlopen(
  "./target/debug/libhello_ffi.so",
  {
    "add": { parameters: ["usize", "usize"], result: "usize" },
  } as const,
);

console.log(`3 + 6 = ${dylib.symbols.add(3, 6)}`);
```

`Deno.dlopen`을 사용해서 공유라이브러리를 불러옵니다. 이 함수는 두가지를
요구하는데요. 첫번째로 공유 라이브러리 파일의 위치가 필요합니다. 파일은 굳이
local에 있을 필요는 없고, remote uri를 넘겨줘도 잘 작동합니다. 실제 사용하는
케이스들을 보면 release한 공유 라이브러리 파일을 CDN에 올려놓고 가져다 쓰는
방법을 많이 쓰는 것 같습니다.

두번째로는 공유라이브러리에 정의된 함수의 인터페이스 정보를 받습니다. Deno는 이
정보를 기준으로 라이브러리의 함수와 통신하게 됩니다. 또 타이핑을 굉장히
잘해놓아서, 매번 함수의 인터페이스가 어떤지 확인할 필요가 없이 `dylib.symbols`에
정의된 함수를 IDE의 도움을 받아서 편하게 쓸 수 있습니다.

```
deno --allow-read --allow-ffi --unstable main.ts
```

권한은 ffi를 사용하기 위한 `--allow-ffi`, 라이브러리 파일을 읽어오기 위한
`--allow-read`가 필요합니다. 만약 remote url로 파일을 가져온다면 `--allow-net`이
필요합니다.

```
3 + 6 = 9
```

완벽하군요. ☺️

# deno_bindgen?

공식 문서에서 이미 발견하셨을지도 모르겠습니다만. deno에서 좀 더 편하게 ffi를 쓸
수 있도록 `deno_bindgen`라는 라이브러리를 제공합니다.

제 개인적인 의견으로는, 현재 (2023-02-22) 기준으로는 아직 사용하기 적합하지 않은
미성숙한 라이브러리인 것 같습니다.

가장 큰 문제는 메모리 누수입니다. deno_bindgen이 복잡한 return value를 deno
런타임으로 전달하기 위해서 포인터를 사용하는데, 현재 구현에서는 메모리 할당 후
free를 하지 않고 있습니다. 현재 이슈도 올라와있고 그렇긴 합니다만, 아직 제대로
해결되기까지는 조금 시간이 걸릴 듯 합니다.

# 하지만...

솔직하게 말해서 현재 FFI를 쓰는 것을 추천드리지는 않습니다. 현재 이 기능이
unstable로 관리되고 있기도 하고. 무엇보다 똑같은 작업을 stable한 기능인 WASM으로
대체할 수 있습니다. 무엇보다 C언어 스펙을 기준으로 만들어진 FFI와 달리, WASM은
JS를 기준으로 만들어졌기 때문에 parameter나 return value를 교환하는 작업도 훨씬
쉽습니다.
